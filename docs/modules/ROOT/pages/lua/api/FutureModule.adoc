= Future Module
:table-caption!:

This Module provides the Future type and all its necessary functionallity.

[cols="1,5a",separator="!"]
!===
!Dependencies
! xref:/lua/api/KernelModule.adoc[KernelModule]
!===

== Globals

=== **async** : fun(fn, ...): xref:/reflection/structs/Future.adoc[Future]
Wraps a function into a future.

=== **future**
The global Future Library provides functions to work more easily with futures.

=== __future.__**addTask** (xref:/reflection/structs/Future.adoc[Future]...)
Adds the given futures to the tasks list.

[%collapsible]
====
.Parameters
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Futures* `...`
! xref:/reflection/structs/Future.adoc[Future]
! The futures you want to add

!===
====

=== __future.__**async** (thread) -> xref:/reflection/structs/Future.adoc[Future]
Wraps the given thread/coroutine in a Lua-Future

[%collapsible]
====
.Parameters
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Thread* `thread`
! thread
! The thread you want to wrap in a future

!===
.Return Values
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Future* `future`
! xref:/reflection/structs/Future.adoc[Future]
! The Future that wraps the given thread

!===
====

=== __future.__**join** (xref:/reflection/structs/Future.adoc[Future]...) -> xref:/reflection/structs/Future.adoc[Future]
Creates a new Future that will only finish once all futures passed as parameters have finished.

[%collapsible]
====
.Parameters
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Futures* `...`
! xref:/reflection/structs/Future.adoc[Future]
! The futures you want to join

!===
.Return Values
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Future* `future`
! xref:/reflection/structs/Future.adoc[Future]
! The Future that will finish once all other futures finished

!===
====

=== __future.__**loop** ()
Runs the default task scheduler indefinitely until no tasks are left.

=== __future.__**run** ()
Runs the default task scheduler once.

=== __future.__**sleep** (seconds: number) -> xref:/reflection/structs/Future.adoc[Future]
Creates a future that returns after the given amount of seconds.

[%collapsible]
====
.Parameters
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Seconds* `seconds`
! number
! Number of seconds to wait

!===
.Return Values
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Future* `future`
! xref:/reflection/structs/Future.adoc[Future]
! The future that will finish after the given amount of seconds

!===
====

=== __future.__**tasks** : 
A list of futures that are considered "Tasks".
Tasks could be seen as background threads. Effectively getting "joined" together.
Examples for tasks are callback invocations of timers and event listeners.

=== **sleep** : fun(seconds: number): xref:/reflection/structs/Future.adoc[Future]
Blocks the current thread/future until the given amount of time passed

== Types

=== **Future**


=== __Future.__**await** ()
Wait for the future to complete and return its value.

[%collapsible]
====
.Return Values
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Value* `...`
! any
! Future's value

!===
====

=== __Future.__**canGet** ()
Check if the future's value is available without performing any additional logic.

[%collapsible]
====
.Return Values
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Can Get* `canGet`
! boolean
! True if future is completed and a value is available

!===
====

=== __Future.__**get** ()
Get value from the future if one is available.
Causes error if future is not yet resolved.

[%collapsible]
====
.Return Values
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Value* `...`
! any
! Future's value

!===
====

=== __Future.__**poll** () -> boolean,number?


[%collapsible]
====
.Return Values
[%header,cols="1,1,4a",separator="!"]
!===
!Name !Type !Description

! *Ready* `ready`
! boolean
! Whether the future is ready or not

! *Timeout* `timeout`
! number?
! 

!===
====

=== **FutureStruct**


